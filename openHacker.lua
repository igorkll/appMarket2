local a=require("event")local b=require("computer")local c=require("serialization")local d=require("text")local e=require("thread")local f=require("component")local g=require("shell")local h;local i,j=g.parse(...)local function k(l,m)return h.yesno("new state at: "..l,true,m and 2 or 1)end;local function n(l)local o=h.inputZone(l)if not o or o==""then return nil end;if o=="inf"then return math.huge end;if o=="-inf"then return-math.huge end;return tonumber(o or"*")end;local function p()_G.openHaker={}_G.openHaker.settings={}_G.openHaker.settings.beepAllow=true;_G.openHaker.settings.timersTickAllow=true;_G.openHaker.settings.listensTickAllow=true;_G.openHaker.settings.pushAllow=true;_G.openHaker.settings.beepCard=false;_G.openHaker.event={}_G.openHaker.event.timers={}_G.openHaker.event.listens={}_G.openHaker.event.registerListens=true;_G.openHaker.event.registerTimers=true;_G.openHaker.event.pull=a.pull;_G.openHaker.event.push=a.push;_G.openHaker.event.timer=a.timer;_G.openHaker.event.listen=a.listen;_G.openHaker.event.register=a.register;_G.openHaker.event.cancel=a.cancel;_G.openHaker.event.ignore=a.ignore;_G.openHaker.computer={}_G.openHaker.computer.beep=b.beep;_G.openHaker.thread={}_G.openHaker.thread.create=e.create;_G.openHaker.thread.threads={}a.push=function(...)if _G.openHaker.settings.pushAllow then return _G.openHaker.event.push(...)else return true end end;a.timer=function(q,r,s,...)if not _G.openHaker.event.registerTimers then return _G.openHaker.event.timer(q,r,s,...)end;checkArg(1,q,"number")checkArg(2,r,"function")checkArg(3,s,"number","nil")if not s then s=1 end;local t=r;local u;local v;local function w(...)local x;for y=1,#_G.openHaker.event.timers do if _G.openHaker.event.timers[y][1]==u then x=y;break end end;if not x then return false end;if _G.openHaker.settings.timersTickAllow and _G.openHaker.event.timers[x][5]then local z={pcall(t,...)}v[4]=math.floor(v[4]-1)if z[1]then if z[2]==false or v[4]<=0 then table.remove(_G.openHaker.event.timers,x)end;return table.unpack(z,2)else if v[4]<=0 then table.remove(_G.openHaker.event.timers,x)end;error(z[2])end end end;local A=_G.openHaker.event.timer(q,w,s,...)v={A,q,t,s,true}table.insert(_G.openHaker.event.timers,v)u=A;return A end;a.register=function(l,r,...)if not _G.openHaker.event.registerListens then return _G.openHaker.event.register(l,r,...)end;checkArg(1,l,"string","nil","boolean")checkArg(2,r,"function")local t=r;local u;local B=({...})[2]local function w(...)local x;for y=1,#_G.openHaker.event.listens do if _G.openHaker.event.listens[y][4]==u then x=y;break end end;if not x then return false end;if _G.openHaker.settings.listensTickAllow and _G.openHaker.event.listens[x][5]then local z={pcall(t,...)}B=math.floor(B-1)if z[1]then if z[2]==false or B<=0 then table.remove(_G.openHaker.event.listens,x)end;return table.unpack(z,2)else if B<=0 then table.remove(_G.openHaker.event.listens,x)end;error(z[2])end end end;local A=_G.openHaker.event.register(l,w,...)table.insert(_G.openHaker.event.listens,{l,t,w,A,true})u=A;return A end;a.ignore=function(l,r,...)checkArg(1,l,"string","nil","boolean")checkArg(2,r,"function")local u;local w=r;for y=1,#_G.openHaker.event.listens do if _G.openHaker.event.listens[y][2]==r and _G.openHaker.event.listens[y][1]==l then w=_G.openHaker.event.listens[y][3]u=y;break end end;local z=_G.openHaker.event.ignore(l,w,...)if z and u then table.remove(_G.openHaker.event.listens,u)end;return z end;a.cancel=function(A)checkArg(1,A,"number")for y=1,#_G.openHaker.event.listens do if A==_G.openHaker.event.listens[y][4]then _G.openHaker.event.cancel(_G.openHaker.event.listens[y][4])table.remove(_G.openHaker.event.listens,y)for y=1,#_G.openHaker.event.timers do if A==_G.openHaker.event.timers[y][1]then _G.openHaker.event.cancel(_G.openHaker.event.timers[y][1])table.remove(_G.openHaker.event.timers,y)return true end end;return true end end;return false end;b.beep=function(...)if _G.openHaker.settings.beepAllow then local i={...}if not i[1]then i[1]=440 end;if not i[2]then i[2]=0.1 end;if _G.openHaker.settings.beepCard and type(i[1])~="string"and f.isAvailable("beep")then f.beep.beep({[i[1]]=i[2]})os.sleep(i[2])else _G.openHaker.computer.beep(...)end end end;e.create=function(r,...)local C=_G.openHaker.thread.create(r,...)table.insert(_G.openHaker.thread.threads,C)return C end end;local function D()local E;local function F()E={"back"}for y=1,#_G.openHaker.event.timers do local G=_G.openHaker.event.timers[y]table.insert(E,"index: "..y..", num: "..math.floor(G[1])..", pereud: "..G[2]..", times: "..G[4]..", active: "..tostring(G[5]))end end;while true do F()while true do local A=h.menu("timers",E)if A==1 then return else A=A-1;local G=_G.openHaker.event.timers[A]while true do F()local H=": "..E[A+1]local I=h.menu("timer control "..H,{"back","kill","set pereud","set times","call","set active"})if I==1 then break elseif I==2 then a.cancel(G[1])break elseif I==3 then local J=n("pereud")a.cancel(G[1])G[2]=J;a.timer(table.unpack(G,2))A=#_G.openHaker.event.timers elseif I==4 then local J=n("times")a.cancel(G[1])G[4]=J;a.timer(table.unpack(G,2))A=#_G.openHaker.event.timers elseif I==5 then local z={xpcall(G[3],debug.traceback)}if#z>1 or z[1]==false then local K=c.serialize(z)h.splash(d.detab(K))end elseif I==6 then G[5]=k("activate",G[5])end end end end end end;local function L()local E;local function F()E={"back"}for y=1,#_G.openHaker.event.listens do local M=_G.openHaker.event.listens[y]table.insert(E,"index: "..y..", num: "..math.floor(M[4])..", event: "..tostring(M[1])..", active: "..tostring(M[5]))end end;while true do F()local A=h.menu("listens",E)if A==1 then return else A=A-1;local M=_G.openHaker.event.listens[A]while true do F()local H=": "..E[A+1]local I=h.menu("listen control"..H,{"back","kill","call","set active"})if I==1 then break elseif I==2 then a.cancel(M[4])break elseif I==3 then local z={xpcall(M[2],debug.traceback)}if#z>1 or z[1]==false then local K=c.serialize(z)h.splash(d.detab(K))end elseif I==4 then M[5]=k("activate",M[5])end end end end end;local function N()local E;local function F()E={"back"}for y=1,#_G.openHaker.thread.threads do local C=_G.openHaker.thread.threads[y]table.insert(E,"index: "..y..", state: "..C:status())end end;while true do F()local A=h.menu("threads",E)if A==1 then return else A=A-1;local C=_G.openHaker.thread.threads[A]while true do F()local H=": "..E[A+1]local I=h.menu("thread control"..H,{"back","kill","suspend(stop)","resume(start)"})if I==1 then break elseif I==2 then C:kill()table.remove(_G.openHaker.thread.threads,A)break elseif I==3 then C:suspend()elseif I==4 then C:resume()end end end end end;local function O()while true do local A=h.menu("event",{"push allow","timer tick allow","listen tick allow","timer menager","listen menager","back"})if A==1 then _G.openHaker.settings.pushAllow=k("pushAllow",_G.openHaker.settings.pushAllow)elseif A==2 then _G.openHaker.settings.timersTickAllow=k("timersTickAllow",_G.openHaker.settings.timersTickAllow)elseif A==3 then _G.openHaker.settings.listensTickAllow=k("listensTickAllow",_G.openHaker.settings.listensTickAllow)elseif A==4 then D()elseif A==5 then L()elseif A==6 then return end end end;local function P()while true do local A=h.menu("thread",{"thread menager","back"})if A==1 then N()elseif A==2 then return end end end;local function Q()while true do local A=h.menu("optimization",{"computer.beep to beep card","back"})if A==1 then _G.openHaker.settings.beepCard=k("set",_G.openHaker.settings.beepCard)elseif A==2 then return end end end;if not _G.openHaker then p()end;if not j.l then h=require("simpleGui2").create()end;while not j.l do local A=h.menu("open haker",{"event","thread","optimization","back"})if A==1 then O()elseif A==2 then P()elseif A==3 then Q()elseif A==4 then h.exit()end end